% задание 6(p06) проверяем, является ли наш список палиндромом

-module(p06).
-export([is_palindrome/1]).

% тесты для данного задания
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
is_palindrome_test_() ->
[?_assert(is_palindrome([0,4,1,4,0]) == true),
?_assert(is_palindrome([3,t]) == false),
?_assertNot(is_palindrome([a,b,c]) == true),
?_assertMatch(true, is_palindrome([8,d,2,d,8])),
?_assertEqual(is_palindrome([a,b,c,d]), is_palindrome([a,b,c,d]))].
-endif.

% создаем функцию, которая проверяет на равенство между собой вводимый список, и тот же список только перевернутый, я поставил равенство по типу(=:=) что-бы избежать чисел с плавающей точкой, которые могут быть равны целым числам:
is_palindrome(List) -> List =:= reverse(List).

% дальше просто вставляем код из предыдущей задачи(p05), с помощью которого мы делаем наш список перевернутым:
  
% функция с одной переменной вызывает другую сункцию с двумя переменными, и срабатывает если во второй функции 2-я переменная - пустой список:
reverse(List) -> 
   reverse(List,[]).

% создаем функцию, которая выводит свою 2-ю переменную если 1-й переменной является пустой список:
	reverse([],Res) -> 
	   Res;

% если в списке есть какие либо значения, то срабатывает данная функция, которая с каждой итерацией записывает в себя по одному значению с головы, а хвост выводит в начало пока наш список не станет пустым:
	reverse([H|T],Res) -> 
	   reverse(T,[H|Res]).
